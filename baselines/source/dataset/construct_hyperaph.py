"""
transform graphs (represented by edge list) to hypergraph (represented by node_dict & edge_dict)
"""
from typing import Optional
import numpy as np
from omegaconf import DictConfig
from sklearn.metrics.pairwise import cosine_distances as cos_dis
import torch

import ipdb


def hyperedge_concat(*H_list):
    """
    Concatenate hyperedge group in H_list
    :param H_list: Hyperedge groups which contain two or more hypergraph incidence matrix
    :return: Fused hypergraph incidence matrix
    """
    H = None
    for h in H_list:
        if h is not None:
            # for the first H appended to fused hypergraph incidence matrix
            if H is None:
                H = h
            else:
                H = np.hstack((H, h))
    return H


def construct_H_with_KNN(X, K_neigs=[10], is_probH=False, m_prob=1):
    """
    init multi-scale hypergraph Vertex-Edge matrix from original node feature matrix
    :param X: N_object x feature_number
    :param K_neigs: the number of neighbor expansion
    :param is_probH: prob Vertex-Edge matrix or binary
    :param m_prob: prob
    :return: N_object x N_hyperedge
    """
    ipdb.set_trace()
    if len(X.shape) != 2:
        X = X.reshape(-1, X.shape[-1])

    if type(K_neigs) == int:
        K_neigs = [K_neigs]

    dis_mat = cos_dis(X)
    H = None
    for k_neig in K_neigs:
        H_tmp = construct_H_with_KNN_from_distance(
            dis_mat, k_neig, is_probH, m_prob)
        H = hyperedge_concat(H, H_tmp)
    return H


def construct_H_with_KNN_from_distance(dis_mat, k_neig, is_probH=False, m_prob=1):
    """
    construct hypregraph incidence matrix from hypergraph node distance matrix
    :param dis_mat: node distance matrix
    :param k_neig: K nearest neighbor
    :param is_probH: prob Vertex-Edge matrix or binary
    :param m_prob: prob
    :return: N_object X N_hyperedge
    """
    n_obj = dis_mat.shape[0]
    # construct hyperedge from the central feature space of each node
    n_edge = n_obj
    H = np.zeros((n_obj, n_edge))
    for center_idx in range(n_obj):
        dis_mat[center_idx, center_idx] = 0
        dis_vec = dis_mat[center_idx]
        nearest_idx = np.array(np.argsort(dis_vec)).squeeze()
        avg_dis = np.average(dis_vec)
        if not np.any(nearest_idx[:k_neig] == center_idx):
            nearest_idx[k_neig - 1] = center_idx

        for node_idx in nearest_idx[:k_neig]:
            if is_probH:
                H[node_idx, center_idx] = np.exp(
                    -dis_vec[0, node_idx] ** 2 / (m_prob * avg_dis) ** 2)
            else:
                H[node_idx, center_idx] = 1.0
    return H


def _generate_G_from_H(H, variable_weight=False):
    """
    calculate G from hypgraph incidence matrix H
    :param H: hypergraph incidence matrix H
    :param variable_weight: whether the weight of hyperedge is variable
    :return: G
    """
    H = np.array(H)
    n_edge = H.shape[1]
    # the weight of the hyperedge
    W = np.ones(n_edge)
    # the degree of the node
    DV = np.sum(H * W, axis=1)
    # the degree of the hyperedge
    DE = np.sum(H, axis=0)

    invDE = np.mat(np.diag(np.power(DE, -1)))
    DV2 = np.mat(np.diag(np.power(DV, -0.5)))
    W = np.mat(np.diag(W))
    H = np.mat(H)
    HT = H.T

    if variable_weight:
        DV2_H = DV2 * H
        invDE_HT_DV2 = invDE * HT * DV2
        return DV2_H, W, invDE_HT_DV2
    else:
        G = DV2 * H * W * invDE * HT * DV2
        return G


def generate_G_from_H(H, variable_weight=False):
    """
    calculate G from hypgraph incidence matrix H
    :param H: hypergraph incidence matrix H
    :param variable_weight: whether the weight of hyperedge is variable
    :return: G
    """
    if type(H) != list:
        return _generate_G_from_H(H, variable_weight)
    else:
        G = []
        for sub_H in H:
            G.append(generate_G_from_H(sub_H, variable_weight))
        return G


def construct_G_from_fts(Xs, k_neighbors):
    """
    generate G from concatenated H from list of features
    :param Xs: list of features
    :param k_neighs: list of k
    :return: numpy array
    """
    Hs = [construct_H_with_KNN(Xs[i], [k_neighbors[i]])
          for i in range(len(Xs))]
    H = np.concatenate(Hs, axis=1)
    G = generate_G_from_H(H)
    return G


def create_hypergraph_feature(feature):

    # number of nodes
    m = feature.shape[1]

    for i in range(feature.shape[0]):
        # Taking upper triangular part of each converted matrixes
        t = np.triu(feature[i, :, :])
        # Creating 1xK matrixes which K is connectivity number of upper triangular part.
        x = t[np.triu_indices(m, 1)]
        x1 = x.transpose()
        Featurematrix = np.empty((0, x1.shape[0]), int)
        Featurematrix = np.append(Featurematrix, np.array([x1]), axis=0)
    return Featurematrix


def create_hypergraph_data(cfg: DictConfig,
                           final_pearson: torch.Tensor,
                           node_feature: torch.Tensor,
                           labels: torch.Tensor,
                           site: torch.Tensor,
                           site_mapping: dict,
                           final_sc: Optional[torch.Tensor] = None):

    K_neigs = cfg.model.K_neigs
    is_probH = cfg.model.is_probH
    

    Xs = []
    Xs = [create_hypergraph_feature(final_pearson)]
    if final_sc is not None:
        Xs.append(create_hypergraph_feature(final_sc))

    H = [construct_H_with_KNN(Xs[i], [K_neigs], is_probH)
         for i in range(len(Xs))]

    return H
